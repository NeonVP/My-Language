#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "backend/CodeGen.h"
#include "DebugUtils.h"
#include "UtilsRW.h"
#include "Tree.h"

// ========== АРХИТЕКТУРА ЦЕЛЕВОГО ПРОЦЕССОРА ==========
//
// Стековая виртуальная машина с регистрами:
// - RAX, RBX, RCX, RDX - регистры общего назначения
// - [rsp] - стек для вычислений
// - [rbp+offset] - локальные переменные
//
// Инструкции:
// push <val>    - положить значение на стек
// pop <reg>     - снять значение со стека в регистр
// add           - сложение двух верхних элементов стека
// sub           - вычитание
// mul           - умножение
// div           - деление
// sqrt          - квадратный корень из верхнего элемента
// call <label>  - вызов функции
// ret           - возврат из функции
// jmp <label>   - безусловный переход
// jz <label>    - переход если ноль
// in            - ввод числа
// out           - вывод числа
// hlt           - останов программы

static void GenNode( CodeGen_t* codegen, Node_t* node );
static void GenExpression( CodeGen_t* codegen, Node_t* node );
static void GenFunction( CodeGen_t* codegen, Node_t* node );
static void GenStatement( CodeGen_t* codegen, Node_t* node );
static int GetNewLabel( CodeGen_t* codegen );

CodeGen_t* CodeGenCtor( const char* input_file, const char* output_file ) {
    CodeGen_t* codegen = (CodeGen_t*)calloc( 1, sizeof(CodeGen_t) );
    if ( !codegen ) {
        PRINT_ERROR( "Failed to allocate CodeGen_t" );
        return NULL;
    }

    codegen->input_filename = strdup( input_file );
    codegen->output_filename = strdup( output_file );
    
    codegen->output = fopen( output_file, "w" );
    if ( !codegen->output ) {
        PRINT_ERROR( "Failed to open output file: %s", output_file );
        free( codegen->input_filename );
        free( codegen->output_filename );
        free( codegen );
        return NULL;
    }

    codegen->label_counter = 0;
    codegen->temp_var_counter = 0;

    PRINT( "CodeGen created for: %s -> %s", input_file, output_file );
    return codegen;
}

void CodeGenDtor( CodeGen_t** codegen ) {
    if ( !codegen || !*codegen )
        return;

    if ( (*codegen)->output )
        fclose( (*codegen)->output );

    free( (*codegen)->input_filename );
    free( (*codegen)->output_filename );
    
    if ( (*codegen)->tree )
        TreeDtor( &(*codegen)->tree, NULL );

    free( *codegen );
    *codegen = NULL;
}

static int GetNewLabel( CodeGen_t* codegen ) {
    return codegen->label_counter++;
}

void GenerateCode( CodeGen_t* codegen ) {
    my_assert( codegen, "Null pointer on codegen" );
    my_assert( codegen->tree, "Null pointer on tree" );
    my_assert( codegen->tree->root, "Null pointer on tree root" );

    PRINT( "Starting code generation..." );

    FILE* out = codegen->output;

    // Заголовок программы
    fprintf( out, "; Generated by My-Language Compiler\n" );
    fprintf( out, "; Source: %s\n\n", codegen->input_filename );

    // Генерация кода для всего AST
    GenNode( codegen, codegen->tree->root );

    // Завершение программы
    fprintf( out, "\nhlt\n" );

    PRINT( "Code generation complete" );
}

static void GenNode( CodeGen_t* codegen, Node_t* node ) {
    if ( !node )
        return;

    FILE* out = codegen->output;

    if ( node->value.type == NODE_NUMBER ) {
        fprintf( out, "push %d\n", node->value.data.number );
        return;
    }

    if ( node->value.type == NODE_VARIABLE ) {
        // Загрузка переменной на стек
        fprintf( out, "push [%s]\n", node->value.data.variable );
        return;
    }

    if ( node->value.type == NODE_OPERATION ) {
        OperationType op = (OperationType)node->value.data.operation;

        switch ( op ) {
            // ===== ФУНКЦИИ =====
            case OP_MAIN:
            case OP_FUNC:
                GenFunction( codegen, node );
                break;

            // ===== ПОСЛЕДОВАТЕЛЬНОСТЬ ОПЕРАТОРОВ =====
            case OP_SEMICOLON:
                GenNode( codegen, node->left );
                GenNode( codegen, node->right );
                break;

            // ===== ОБЪЯВЛЕНИЕ/ПРИСВАИВАНИЕ =====
            case OP_ADVERT:
            case OP_ASSIGN:
                GenExpression( codegen, node->right );
                fprintf( out, "pop [%s]\n", node->left->value.data.variable );
                break;

            // ===== АРИФМЕТИКА =====
            case OP_ADD:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "add\n" );
                break;

            case OP_SUB:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "sub\n" );
                break;

            case OP_MUL:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "mul\n" );
                break;

            case OP_DIV:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "div\n" );
                break;

            case OP_POW:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "pow\n" );
                break;

            case OP_SQRT:
                GenExpression( codegen, node->left );
                fprintf( out, "sqrt\n" );
                break;

            // ===== УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ =====
            case OP_IF: {
                int else_label = GetNewLabel( codegen );
                int end_label = GetNewLabel( codegen );

                // Вычисляем условие
                GenExpression( codegen, node->left );
                fprintf( out, "push 0\n" );
                fprintf( out, "je .L%d\n", else_label );

                // Then-ветка
                if ( node->right && node->right->value.type == NODE_OPERATION &&
                     (OperationType)node->right->value.data.operation == OP_ELSE ) {
                    GenNode( codegen, node->right->left );
                    fprintf( out, "jmp .L%d\n", end_label );
                    
                    // Else-ветка
                    fprintf( out, ".L%d:\n", else_label );
                    GenNode( codegen, node->right->right );
                } else {
                    GenNode( codegen, node->right );
                    fprintf( out, "jmp .L%d\n", end_label );
                    fprintf( out, ".L%d:\n", else_label );
                }

                fprintf( out, ".L%d:\n", end_label );
                break;
            }

            case OP_WHILE: {
                int start_label = GetNewLabel( codegen );
                int end_label = GetNewLabel( codegen );

                fprintf( out, ".L%d:\n", start_label );
                
                // Вычисляем условие
                GenExpression( codegen, node->left );
                fprintf( out, "push 0\n" );
                fprintf( out, "je .L%d\n", end_label );

                // Тело цикла
                GenNode( codegen, node->right );
                fprintf( out, "jmp .L%d\n", start_label );

                fprintf( out, ".L%d:\n", end_label );
                break;
            }

            case OP_RETURN:
                GenExpression( codegen, node->left );
                fprintf( out, "ret\n" );
                break;

            // ===== ВВОД/ВЫВОД =====
            case OP_IN:
                fprintf( out, "in\n" );
                break;

            case OP_OUT:
                GenExpression( codegen, node->left );
                fprintf( out, "out\n" );
                break;

            // ===== ВЫЗОВ ФУНКЦИИ =====
            case OP_CALL: {
                // Получаем имя функции
                const char* func_name = node->left->value.data.variable;
                
                // Генерируем код для аргументов (они на стеке)
                Node_t* args = node->right;
                int arg_count = 0;
                
                // Подсчитываем и генерируем аргументы
                Node_t* arg = args;
                while ( arg ) {
                    if ( arg->value.type == NODE_OPERATION &&
                         (OperationType)arg->value.data.operation == OP_COMMA ) {
                        GenExpression( codegen, arg->left );
                        arg = arg->right;
                        arg_count++;
                    } else {
                        GenExpression( codegen, arg );
                        arg_count++;
                        break;
                    }
                }

                fprintf( out, "call %s\n", func_name );
                break;
            }

            default:
                PRINT_ERROR( "Unknown operation type: %d", op );
                break;
        }
    }
}

static void GenExpression( CodeGen_t* codegen, Node_t* node ) {
    if ( !node )
        return;

    FILE* out = codegen->output;

    if ( node->value.type == NODE_NUMBER ) {
        fprintf( out, "push %d\n", node->value.data.number );
        return;
    }

    if ( node->value.type == NODE_VARIABLE ) {
        fprintf( out, "push [%s]\n", node->value.data.variable );
        return;
    }

    if ( node->value.type == NODE_OPERATION ) {
        OperationType op = (OperationType)node->value.data.operation;

        switch ( op ) {
            case OP_ADD:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "add\n" );
                break;

            case OP_SUB:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "sub\n" );
                break;

            case OP_MUL:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "mul\n" );
                break;

            case OP_DIV:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "div\n" );
                break;

            case OP_POW:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "pow\n" );
                break;

            case OP_SQRT:
                GenExpression( codegen, node->left );
                fprintf( out, "sqrt\n" );
                break;

            case OP_IN:
                fprintf( out, "in\n" );
                break;

            case OP_CALL: {
                const char* func_name = node->left->value.data.variable;
                Node_t* args = node->right;
                
                // Генерируем аргументы
                Node_t* arg = args;
                while ( arg ) {
                    if ( arg->value.type == NODE_OPERATION &&
                         (OperationType)arg->value.data.operation == OP_COMMA ) {
                        GenExpression( codegen, arg->left );
                        arg = arg->right;
                    } else {
                        GenExpression( codegen, arg );
                        break;
                    }
                }

                fprintf( out, "call %s\n", func_name );
                break;
            }

            default:
                GenNode( codegen, node );
                break;
        }
    }
}

static void GenFunction( CodeGen_t* codegen, Node_t* node ) {
    if ( !node )
        return;

    FILE* out = codegen->output;
    OperationType op = (OperationType)node->value.data.operation;

    // node->left содержит (, func_name params)
    // node->right содержит тело функции

    Node_t* func_info = node->left;
    if ( !func_info || func_info->value.type != NODE_OPERATION ||
         (OperationType)func_info->value.data.operation != OP_COMMA ) {
        PRINT_ERROR( "Invalid function structure" );
        return;
    }

    const char* func_name = func_info->left->value.data.variable;
    Node_t* params = func_info->right;

    // Генерируем метку функции
    fprintf( out, "\n%s:\n", func_name );

    // Пролог функции
    fprintf( out, "push rbp\n" );
    fprintf( out, "mov rbp, rsp\n" );

    // Обрабатываем параметры (они уже на стеке)
    int param_count = 0;
    Node_t* param = params;
    while ( param ) {
        if ( param->value.type == NODE_OPERATION &&
             (OperationType)param->value.data.operation == OP_COMMA ) {
            param = param->right;
            param_count++;
        } else if ( param->value.type == NODE_VARIABLE ) {
            param_count++;
            break;
        } else {
            break;
        }
    }

    // Генерируем тело функции
    GenNode( codegen, node->right );

    // Эпилог функции (если нет явного return)
    if ( op == OP_MAIN ) {
        fprintf( out, "push 0\n" );
    }
    fprintf( out, "mov rsp, rbp\n" );
    fprintf( out, "pop rbp\n" );
    fprintf( out, "ret\n" );
}
