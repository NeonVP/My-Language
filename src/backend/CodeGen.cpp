#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "backend/CodeGen.h"
#include "DebugUtils.h"
#include "UtilsRW.h"
#include "Tree.h"

// ========== АРХИТЕКТУРА My-Compiler-and-Processor ==========
//
// Стековая виртуальная машина с командами:
// PUSH <val>    - положить значение/регистр на стек
// POP <reg>     - снять значение со стека в регистр
// ADD           - сложение верхних элементов стека
// SUB           - вычитание
// MUL           - умножение
// DIV           - деление
// POW           - возведение в степень
// SQRT          - квадратный корень
// CALL :<label> - вызов функции
// RET           - возврат из функции
// JMP :<label>  - безусловный переход
// JE :<label>   - переход если равно (после сравнения)
// JB :<label>   - переход если меньше
// JA :<label>   - переход если больше
// JBE :<label>  - переход если меньше или равно
// JAE :<label>  - переход если больше или равно
// IN            - ввод числа
// OUT           - вывод числа
// HLT           - останов программы
//
// Метки: :<name> или :<number>
// Регистры: RAX, RBX, RCX, RDX

static void GenNode( CodeGen_t* codegen, Node_t* node );
static void GenExpression( CodeGen_t* codegen, Node_t* node );
static void GenFunction( CodeGen_t* codegen, Node_t* node );
static void GenStatement( CodeGen_t* codegen, Node_t* node );
static int GetNewLabel( CodeGen_t* codegen );

CodeGen_t* CodeGenCtor( const char* input_file, const char* output_file ) {
    CodeGen_t* codegen = (CodeGen_t*)calloc( 1, sizeof(CodeGen_t) );
    if ( !codegen ) {
        PRINT_ERROR( "Failed to allocate CodeGen_t" );
        return NULL;
    }

    codegen->input_filename = strdup( input_file );
    codegen->output_filename = strdup( output_file );
    
    codegen->output = fopen( output_file, "w" );
    if ( !codegen->output ) {
        PRINT_ERROR( "Failed to open output file: %s", output_file );
        free( codegen->input_filename );
        free( codegen->output_filename );
        free( codegen );
        return NULL;
    }

    codegen->label_counter = 0;
    codegen->temp_var_counter = 0;

    PRINT( "CodeGen created for: %s -> %s", input_file, output_file );
    return codegen;
}

void CodeGenDtor( CodeGen_t** codegen ) {
    if ( !codegen || !*codegen )
        return;

    if ( (*codegen)->output )
        fclose( (*codegen)->output );

    free( (*codegen)->input_filename );
    free( (*codegen)->output_filename );
    
    if ( (*codegen)->tree )
        TreeDtor( &(*codegen)->tree, NULL );

    free( *codegen );
    *codegen = NULL;
}

static int GetNewLabel( CodeGen_t* codegen ) {
    return codegen->label_counter++;
}

void GenerateCode( CodeGen_t* codegen ) {
    my_assert( codegen, "Null pointer on codegen" );
    my_assert( codegen->tree, "Null pointer on tree" );
    my_assert( codegen->tree->root, "Null pointer on tree root" );

    PRINT( "Starting code generation..." );

    FILE* out = codegen->output;

    // Заголовок программы
    fprintf( out, "; Generated by My-Language Compiler\n" );
    fprintf( out, "; Target: My-Compiler-and-Processor\n" );
    fprintf( out, "; Source: %s\n\n", codegen->input_filename );

    // Генерация кода для всего AST
    GenNode( codegen, codegen->tree->root );

    // Завершение программы
    fprintf( out, "\nHLT\n" );

    PRINT( "Code generation complete" );
}

static void GenNode( CodeGen_t* codegen, Node_t* node ) {
    if ( !node )
        return;

    FILE* out = codegen->output;

    if ( node->value.type == NODE_NUMBER ) {
        fprintf( out, "PUSH %d\n", node->value.data.number );
        return;
    }

    if ( node->value.type == NODE_VARIABLE ) {
        // Загрузка переменной - используем RAX как временный регистр
        fprintf( out, "PUSH RAX        ; load variable %s\n", node->value.data.variable );
        return;
    }

    if ( node->value.type == NODE_OPERATION ) {
        OperationType op = (OperationType)node->value.data.operation;

        switch ( op ) {
            // ===== ФУНКЦИИ =====
            case OP_MAIN:
            case OP_FUNC:
                GenFunction( codegen, node );
                break;

            // ===== ПОСЛЕДОВАТЕЛЬНОСТЬ ОПЕРАТОРОВ =====
            case OP_SEMICOLON:
                GenNode( codegen, node->left );
                GenNode( codegen, node->right );
                break;

            // ===== ОБЪЯВЛЕНИЕ/ПРИСВАИВАНИЕ =====
            case OP_ADVERT:
            case OP_ASSIGN:
                GenExpression( codegen, node->right );
                fprintf( out, "POP RAX         ; store to %s\n", node->left->value.data.variable );
                break;

            // ===== АРИФМЕТИКА =====
            case OP_ADD:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "ADD\n" );
                break;

            case OP_SUB:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "SUB\n" );
                break;

            case OP_MUL:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "MUL\n" );
                break;

            case OP_DIV:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "DIV\n" );
                break;

            case OP_POW:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "POW\n" );
                break;

            case OP_SQRT:
                GenExpression( codegen, node->left );
                fprintf( out, "SQRT\n" );
                break;

            // ===== УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ =====
            case OP_IF: {
                int else_label = GetNewLabel( codegen );
                int end_label = GetNewLabel( codegen );

                // Вычисляем условие
                GenExpression( codegen, node->left );
                fprintf( out, "PUSH 1\n" );
                fprintf( out, "JBE :%d\n", else_label );  // если условие <= 1 (0 или 1), переход

                // Then-ветка
                if ( node->right && node->right->value.type == NODE_OPERATION &&
                     (OperationType)node->right->value.data.operation == OP_ELSE ) {
                    GenNode( codegen, node->right->left );
                    fprintf( out, "JMP :%d\n", end_label );
                    
                    // Else-ветка
                    fprintf( out, ":%d\n", else_label );
                    GenNode( codegen, node->right->right );
                } else {
                    GenNode( codegen, node->right );
                    fprintf( out, "JMP :%d\n", end_label );
                    fprintf( out, ":%d\n", else_label );
                }

                fprintf( out, ":%d\n", end_label );
                break;
            }

            case OP_WHILE: {
                int start_label = GetNewLabel( codegen );
                int end_label = GetNewLabel( codegen );

                fprintf( out, ":%d\n", start_label );
                
                // Вычисляем условие
                GenExpression( codegen, node->left );
                fprintf( out, "PUSH 1\n" );
                fprintf( out, "JBE :%d\n", end_label );  // если условие <= 1, выход

                // Тело цикла
                GenNode( codegen, node->right );
                fprintf( out, "JMP :%d\n", start_label );

                fprintf( out, ":%d\n", end_label );
                break;
            }

            case OP_RETURN:
                GenExpression( codegen, node->left );
                fprintf( out, "POP RBX         ; return value\n" );
                fprintf( out, "RET\n" );
                break;

            // ===== ВВОД/ВЫВОД =====
            case OP_IN:
                fprintf( out, "IN\n" );
                break;

            case OP_OUT:
                GenExpression( codegen, node->left );
                fprintf( out, "OUT\n" );
                break;

            // ===== ВЫЗОВ ФУНКЦИИ =====
            case OP_CALL: {
                // Получаем имя функции
                const char* func_name = node->left->value.data.variable;
                
                // Генерируем код для аргументов (они на стеке)
                Node_t* args = node->right;
                
                // Подсчитываем и генерируем аргументы
                Node_t* arg = args;
                while ( arg ) {
                    if ( arg->value.type == NODE_OPERATION &&
                         (OperationType)arg->value.data.operation == OP_COMMA ) {
                        GenExpression( codegen, arg->left );
                        arg = arg->right;
                    } else {
                        GenExpression( codegen, arg );
                        break;
                    }
                }

                fprintf( out, "CALL :%s\n", func_name );
                break;
            }

            default:
                PRINT_ERROR( "Unknown operation type: %d", op );
                break;
        }
    }
}

static void GenExpression( CodeGen_t* codegen, Node_t* node ) {
    if ( !node )
        return;

    FILE* out = codegen->output;

    if ( node->value.type == NODE_NUMBER ) {
        fprintf( out, "PUSH %d\n", node->value.data.number );
        return;
    }

    if ( node->value.type == NODE_VARIABLE ) {
        // Загружаем переменную через регистр
        fprintf( out, "PUSH RAX        ; load %s\n", node->value.data.variable );
        return;
    }

    if ( node->value.type == NODE_OPERATION ) {
        OperationType op = (OperationType)node->value.data.operation;

        switch ( op ) {
            case OP_ADD:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "ADD\n" );
                break;

            case OP_SUB:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "SUB\n" );
                break;

            case OP_MUL:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "MUL\n" );
                break;

            case OP_DIV:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "DIV\n" );
                break;

            case OP_POW:
                GenExpression( codegen, node->left );
                GenExpression( codegen, node->right );
                fprintf( out, "POW\n" );
                break;

            case OP_SQRT:
                GenExpression( codegen, node->left );
                fprintf( out, "SQRT\n" );
                break;

            case OP_IN:
                fprintf( out, "IN\n" );
                break;

            case OP_CALL: {
                const char* func_name = node->left->value.data.variable;
                Node_t* args = node->right;
                
                // Генерируем аргументы
                Node_t* arg = args;
                while ( arg ) {
                    if ( arg->value.type == NODE_OPERATION &&
                         (OperationType)arg->value.data.operation == OP_COMMA ) {
                        GenExpression( codegen, arg->left );
                        arg = arg->right;
                    } else {
                        GenExpression( codegen, arg );
                        break;
                    }
                }

                fprintf( out, "CALL :%s\n", func_name );
                break;
            }

            default:
                GenNode( codegen, node );
                break;
        }
    }
}

static void GenFunction( CodeGen_t* codegen, Node_t* node ) {
    if ( !node )
        return;

    FILE* out = codegen->output;
    OperationType op = (OperationType)node->value.data.operation;

    // node->left содержит (, func_name params)
    // node->right содержит тело функции

    Node_t* func_info = node->left;
    if ( !func_info || func_info->value.type != NODE_OPERATION ||
         (OperationType)func_info->value.data.operation != OP_COMMA ) {
        PRINT_ERROR( "Invalid function structure" );
        return;
    }

    const char* func_name = func_info->left->value.data.variable;
    Node_t* params = func_info->right;

    // Генерируем метку функции (формат :<name>)
    fprintf( out, "\n:%s\n", func_name );

    // Обрабатываем параметры - снимаем их со стека
    // Для простоты пока используем RAX для первого параметра
    Node_t* param = params;
    if ( param && param->value.type == NODE_VARIABLE ) {
        fprintf( out, "POP RAX         ; param: %s\n", param->value.data.variable );
    } else if ( param && param->value.type == NODE_OPERATION &&
                (OperationType)param->value.data.operation == OP_COMMA ) {
        // Несколько параметров
        while ( param ) {
            if ( param->value.type == NODE_OPERATION &&
                 (OperationType)param->value.data.operation == OP_COMMA ) {
                if ( param->left && param->left->value.type == NODE_VARIABLE ) {
                    fprintf( out, "POP RAX         ; param: %s\n", param->left->value.data.variable );
                }
                param = param->right;
            } else if ( param->value.type == NODE_VARIABLE ) {
                fprintf( out, "POP RAX         ; param: %s\n", param->value.data.variable );
                break;
            } else {
                break;
            }
        }
    }

    // Генерируем тело функции
    GenNode( codegen, node->right );

    // Если это main и нет явного return
    if ( op == OP_MAIN ) {
        fprintf( out, "PUSH 0\n" );
        fprintf( out, "POP RBX         ; return 0\n" );
    }
    
    fprintf( out, "RET\n" );
}
